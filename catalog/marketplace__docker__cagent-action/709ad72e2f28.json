{
  "action_id": "marketplace/docker/cagent-action",
  "version_id": "709ad72e2f28",
  "source": {
    "type": "marketplace",
    "action_yml_path": "blueprints/marketplace/docker/cagent-action/action.yml",
    "origin": "github.com/docker/cagent-action",
    "publisher": "docker",
    "verified": true
  },
  "definition": {
    "name": "CAgent Runner",
    "description": "Run a CAgent AI agent with a single line",
    "author": "Docker",
    "inputs": [
      {
        "name": "agent",
        "required": true,
        "default": null,
        "description": "Agent identifier (e.g., docker/code-analyzer from Docker Hub, or path to .yaml file)"
      },
      {
        "name": "prompt",
        "required": false,
        "default": null,
        "description": "Prompt to pass to the agent. If not provided, uses a default based on the agent type"
      },
      {
        "name": "cagent-version",
        "required": false,
        "default": "v1.9.12",
        "description": "Version of cagent to use"
      },
      {
        "name": "mcp-gateway",
        "required": false,
        "default": "false",
        "description": "Install mcp-gateway (true/false)"
      },
      {
        "name": "mcp-gateway-version",
        "required": false,
        "default": "v0.22.0",
        "description": "Version of mcp-gateway to use (specifying this will enable mcp-gateway installation)"
      },
      {
        "name": "anthropic-api-key",
        "required": false,
        "default": null,
        "description": "Anthropic API key (defaults to ANTHROPIC_API_KEY secret)"
      },
      {
        "name": "openai-api-key",
        "required": false,
        "default": null,
        "description": "OpenAI API key (defaults to OPENAI_API_KEY secret)"
      },
      {
        "name": "google-api-key",
        "required": false,
        "default": null,
        "description": "Google API key for Gemini (defaults to GOOGLE_API_KEY secret)"
      },
      {
        "name": "github-token",
        "required": false,
        "default": null,
        "description": "GitHub token for API access (defaults to GITHUB_TOKEN env var)"
      },
      {
        "name": "timeout",
        "required": false,
        "default": "0",
        "description": "Timeout in seconds for agent execution (0 for no timeout)"
      },
      {
        "name": "debug",
        "required": false,
        "default": "false",
        "description": "Enable debug mode with verbose logging (true/false)"
      },
      {
        "name": "working-directory",
        "required": false,
        "default": ".",
        "description": "Working directory to run the agent in"
      },
      {
        "name": "yolo",
        "required": false,
        "default": "true",
        "description": "Enable yolo mode - auto-approve all prompts (true/false)"
      },
      {
        "name": "extra-args",
        "required": false,
        "default": "",
        "description": "Additional arguments to pass to cagent exec"
      }
    ],
    "outputs": [
      {
        "name": "exit-code",
        "description": "Exit code from cagent exec"
      },
      {
        "name": "output-file",
        "description": "Path to the output log file"
      },
      {
        "name": "cagent-version",
        "description": "Version of cagent that was used"
      },
      {
        "name": "mcp-gateway-installed",
        "description": "Whether mcp-gateway was installed (true/false)"
      },
      {
        "name": "execution-time",
        "description": "Agent execution time in seconds"
      },
      {
        "name": "security-blocked",
        "description": "Whether execution was blocked due to security concerns"
      },
      {
        "name": "secrets-detected",
        "description": "Whether secrets were detected in output"
      },
      {
        "name": "prompt-suspicious",
        "description": "Whether suspicious patterns were detected in user prompt"
      },
      {
        "name": "input-risk-level",
        "description": "Risk level of input (low/medium/high)"
      }
    ],
    "runs": {
      "using": "composite",
      "steps": [
        {
          "name": "Validate inputs",
          "id": "validate-inputs",
          "shell": "bash",
          "env": {
            "AGENT": "${{ inputs.agent }}",
            "CAGENT_VERSION": "${{ inputs.cagent-version }}",
            "MCP_GATEWAY": "${{ inputs.mcp-gateway }}",
            "MCP_GATEWAY_VERSION": "${{ inputs.mcp-gateway-version }}",
            "DEBUG": "${{ inputs.debug }}",
            "YOLO": "${{ inputs.yolo }}",
            "EXTRA_ARGS": "${{ inputs.extra-args }}"
          },
          "run": "# Validate agent is provided\nif [[ -z \"$AGENT\" ]]; then\n  echo \"::error::'agent' input is required\"\n  exit 1\nfi\n\n# Validate cagent version format\nif ! [[ \"$CAGENT_VERSION\" =~ ^v[0-9]+\\.[0-9]+\\.[0-9]+.*$ ]]; then\n  echo \"::error::Invalid cagent version format '$CAGENT_VERSION'. Expected format: v1.2.3\"\n  exit 1\nfi\n\n# Validate mcp-gateway version format if it will be installed\nif [[ \"$MCP_GATEWAY\" == \"true\" ]]; then\n  if ! [[ \"$MCP_GATEWAY_VERSION\" =~ ^v[0-9]+\\.[0-9]+\\.[0-9]+.*$ ]]; then\n    echo \"::error::Invalid mcp-gateway version format '$MCP_GATEWAY_VERSION'. Expected format: v1.2.3\"\n    exit 1\n  fi\nfi\n\nif [[ \"$DEBUG\" == \"true\" ]]; then\n  echo \"::debug::Validation passed\"\n  echo \"::debug::agent: $AGENT\"\n  echo \"::debug::cagent version: $CAGENT_VERSION\"\n  echo \"::debug::mcp-gateway version: $MCP_GATEWAY_VERSION\"\n  echo \"::debug::mcp-gateway install: $MCP_GATEWAY\"\nfi\n"
        },
        {
          "name": "Sanitize and analyze input",
          "if": "inputs.prompt != ''",
          "id": "sanitize-input",
          "shell": "bash",
          "env": {
            "PROMPT_INPUT": "${{ inputs.prompt }}",
            "ACTION_PATH": "${{ github.action_path }}"
          },
          "run": "echo \"\ud83d\udd0d Checking user-provided prompt for injection patterns...\"\n# Write prompt to temp file for analysis\nprintf '%s\\n' \"$PROMPT_INPUT\" > /tmp/prompt-input.txt\n\n# Run sanitization which outputs risk-level and blocked status\n$ACTION_PATH/security/sanitize-input.sh /tmp/prompt-input.txt /tmp/prompt-clean.txt\n"
        },
        {
          "name": "Cache cagent binary",
          "id": "cache-cagent",
          "uses": "actions/cache@1bd1e32a3bdc45362d1e726936510720a7c30a57",
          "with": {
            "path": "${{ github.workspace }}/cagent",
            "key": "cagent-${{ runner.os }}-${{ inputs.cagent-version }}"
          }
        },
        {
          "name": "Cache mcp-gateway binary",
          "id": "cache-mcp",
          "if": "${{ inputs.mcp-gateway == 'true' }}",
          "uses": "actions/cache@1bd1e32a3bdc45362d1e726936510720a7c30a57",
          "with": {
            "path": "~/.docker/cli-plugins/docker-mcp",
            "key": "mcp-gateway-${{ runner.os }}-${{ inputs.mcp-gateway-version }}"
          }
        },
        {
          "name": "Setup binaries",
          "id": "setup-binaries",
          "shell": "bash",
          "env": {
            "CAGENT_VERSION": "${{ inputs.cagent-version }}",
            "MCP_GATEWAY": "${{ inputs.mcp-gateway }}",
            "MCP_GATEWAY_VERSION": "${{ inputs.mcp-gateway-version }}",
            "DEBUG": "${{ inputs.debug }}",
            "YOLO": "${{ inputs.yolo }}",
            "EXTRA_ARGS": "${{ inputs.extra-args }}",
            "CAGENT_CACHE_HIT": "${{ steps.cache-cagent.outputs.cache-hit }}",
            "MCP_CACHE_HIT": "${{ steps.cache-mcp.outputs.cache-hit }}"
          },
          "run": "set -e\nMCP_INSTALLED=\"false\"\n\nif [[ \"$DEBUG\" == \"true\" ]]; then\n  set -x\nfi\n\n# Function to retry downloads\nretry_download() {\n  local url=$1\n  local output=$2\n  local max_attempts=3\n  local attempt=1\n\n  while [ $attempt -le $max_attempts ]; do\n    echo \"Attempt $attempt of $max_attempts: Downloading $url\"\n    if curl -fL -o \"$output\" \"$url\"; then\n      echo \"Download successful\"\n      return 0\n    fi\n    echo \"Download failed, retrying...\"\n    attempt=$((attempt + 1))\n    sleep 2\n  done\n\n  echo \"::error::Failed to download after $max_attempts attempts: $url\"\n  return 1\n}\n\n# Download cagent if not cached\nif [[ \"$CAGENT_CACHE_HIT\" != \"true\" ]]; then\n  echo \"Downloading cagent $CAGENT_VERSION...\"\n  retry_download \\\n    \"https://github.com/docker/cagent/releases/download/$CAGENT_VERSION/cagent-linux-amd64\" \\\n    \"$GITHUB_WORKSPACE/cagent\"\n  chmod +x \"$GITHUB_WORKSPACE/cagent\"\nelse\n  echo \"Using cached cagent binary\"\nfi\n\n# Verify cagent works\nif ! \"$GITHUB_WORKSPACE/cagent\" version; then\n  echo \"::error::cagent binary verification failed\"\n  exit 1\nfi\n\n# Download mcp-gateway if needed and not cached\nif [[ \"$MCP_GATEWAY\" == \"true\" ]]; then\n  if [[ \"$MCP_CACHE_HIT\" != \"true\" ]]; then\n    echo \"Downloading mcp-gateway $MCP_GATEWAY_VERSION...\"\n    retry_download \\\n      \"https://github.com/docker/mcp-gateway/releases/download/$MCP_GATEWAY_VERSION/docker-mcp-linux-amd64.tar.gz\" \\\n      \"mcp-gateway.tar.gz\"\n    tar -xzf mcp-gateway.tar.gz\n    chmod +x docker-mcp\n    mkdir -p ~/.docker/cli-plugins\n    cp docker-mcp ~/.docker/cli-plugins/docker-mcp\n  else\n    echo \"Using cached mcp-gateway binary\"\n  fi\n\n  # Verify mcp-gateway works\n  if ! docker mcp version; then\n    echo \"::error::mcp-gateway binary verification failed\"\n    exit 1\n  fi\n  MCP_INSTALLED=\"true\"\nfi\n\n# Set outputs\necho \"cagent-version=$CAGENT_VERSION\" >> $GITHUB_OUTPUT\necho \"mcp-installed=$MCP_INSTALLED\" >> $GITHUB_OUTPUT\n"
        },
        {
          "name": "Run CAgent",
          "id": "run-agent",
          "shell": "bash",
          "env": {
            "ANTHROPIC_API_KEY": "${{ inputs.anthropic-api-key || env.ANTHROPIC_API_KEY }}",
            "OPENAI_API_KEY": "${{ inputs.openai-api-key || env.OPENAI_API_KEY }}",
            "GOOGLE_API_KEY": "${{ inputs.google-api-key || env.GOOGLE_API_KEY }}",
            "GITHUB_PERSONAL_ACCESS_TOKEN": "${{ inputs.github-token || github.token }}",
            "AGENT": "${{ inputs.agent }}",
            "PROMPT_INPUT": "${{ inputs.prompt }}",
            "ACTION_PATH": "${{ github.action_path }}",
            "DEBUG": "${{ inputs.debug }}",
            "YOLO": "${{ inputs.yolo }}",
            "EXTRA_ARGS": "${{ inputs.extra-args }}",
            "TIMEOUT": "${{ inputs.timeout }}",
            "WORKING_DIR": "${{ inputs.working-directory }}",
            "CAGENT_VERSION": "${{ inputs.cagent-version }}",
            "MCP_INSTALLED": "${{ steps.setup-binaries.outputs.mcp-installed }}"
          },
          "run": "set -e\n\n# Change to working directory\ncd \"$WORKING_DIR\"\n\nif [[ \"$DEBUG\" == \"true\" ]]; then\n  set -x\n  echo \"::debug::Working directory: $(pwd)\"\n  echo \"::debug::GitHub workspace: $GITHUB_WORKSPACE\"\nfi\n\n# Create output file early (before any validation exits)\n# This ensures downstream steps always have a valid output file reference\nOUTPUT_FILE=$(mktemp /tmp/cagent-output.XXXXXX.log)\necho \"output-file=$OUTPUT_FILE\" >> $GITHUB_OUTPUT\necho \"Output file: $OUTPUT_FILE\"\n\n# Build command arguments array (SECURE: no eval!)\nARGS=(\"exec\")\n\n# Add flags\nif [ \"$YOLO\" = \"true\" ]; then\n  ARGS+=(\"--yolo\")\nfi\n\n# Add extra args if provided\n# Note: This uses simple word splitting. Quoted arguments with spaces are not supported.\n# Using eval would be a security risk with user-provided input.\nif [ -n \"$EXTRA_ARGS\" ]; then\n  read -ra EXTRA_ARGS_ARRAY <<< \"$EXTRA_ARGS\"\n  ARGS+=(\"${EXTRA_ARGS_ARRAY[@]}\")\nfi\n\n# Add agent\necho \"Using agent: $AGENT\"\nARGS+=(\"$AGENT\")\n\n# Add prompt if provided (pass via stdin to avoid \"Argument list too long\" errors)\nif [ -n \"$PROMPT_INPUT\" ]; then\n  ARGS+=(\"-\")\n  echo \"Running cagent with ${#ARGS[@]} arguments (prompt via stdin)\"\nelse\n  echo \"Running cagent with ${#ARGS[@]} arguments (no prompt)\"\nfi\n\n# Track execution time\nSTART_TIME=$(date +%s)\n\n# SECURE: Direct execution with quoted arguments (no eval!)\nset +e  # Don't exit on command failure\nif [ \"$TIMEOUT\" != \"0\" ]; then\n  if [ -n \"$PROMPT_INPUT\" ]; then\n    printf '%s\\n' \"$PROMPT_INPUT\" | timeout \"$TIMEOUT\" \"$GITHUB_WORKSPACE/cagent\" \"${ARGS[@]}\" 2>&1 | tee \"$OUTPUT_FILE\"\n  else\n    timeout \"$TIMEOUT\" \"$GITHUB_WORKSPACE/cagent\" \"${ARGS[@]}\" 2>&1 | tee \"$OUTPUT_FILE\"\n  fi\n  EXIT_CODE=$?\n  if [ $EXIT_CODE -eq 124 ]; then\n    echo \"::error::Agent execution timed out after $TIMEOUT seconds\"\n  fi\nelse\n  if [ -n \"$PROMPT_INPUT\" ]; then\n    printf '%s\\n' \"$PROMPT_INPUT\" | \"$GITHUB_WORKSPACE/cagent\" \"${ARGS[@]}\" 2>&1 | tee \"$OUTPUT_FILE\"\n    EXIT_CODE=${PIPESTATUS[0]}\n  else\n    \"$GITHUB_WORKSPACE/cagent\" \"${ARGS[@]}\" 2>&1 | tee \"$OUTPUT_FILE\"\n    EXIT_CODE=$?\n  fi\nfi\nset -e\n\nEND_TIME=$(date +%s)\nEXECUTION_TIME=$((END_TIME - START_TIME))\n\n# Set outputs (output-file already set at start of step)\necho \"exit-code=$EXIT_CODE\" >> $GITHUB_OUTPUT\necho \"execution-time=$EXECUTION_TIME\" >> $GITHUB_OUTPUT\n\n# Create job summary\n{\n  echo \"## CAgent Execution Summary\"\n  echo \"\"\n  echo \"| Property | Value |\"\n  echo \"|----------|-------|\"\n  echo \"| Agent | \\`$AGENT\\` |\"\n  echo \"| Exit Code | $EXIT_CODE |\"\n  echo \"| Execution Time | ${EXECUTION_TIME}s |\"\n  echo \"| CAgent Version | $CAGENT_VERSION |\"\n  echo \"| MCP Gateway | $MCP_INSTALLED |\"\n  if [ \"$TIMEOUT\" != \"0\" ]; then\n    echo \"| Timeout | ${TIMEOUT}s |\"\n  fi\n  echo \"\"\n\n  if [ $EXIT_CODE -eq 0 ]; then\n    echo \"\u2705 **Status:** Success\"\n  elif [ $EXIT_CODE -eq 124 ]; then\n    echo \"\u23f1\ufe0f **Status:** Timeout\"\n  else\n    echo \"\u274c **Status:** Failed\"\n  fi\n} >> $GITHUB_STEP_SUMMARY\n\nif [[ \"$DEBUG\" == \"true\" ]]; then\n  echo \"::debug::Exit code: $EXIT_CODE\"\n  echo \"::debug::Execution time: ${EXECUTION_TIME}s\"\n  echo \"::debug::Output file: $OUTPUT_FILE\"\nfi\n\nexit $EXIT_CODE\n"
        },
        {
          "name": "Sanitize output",
          "if": "always()",
          "id": "sanitize-output",
          "shell": "bash",
          "env": {
            "OUTPUT_FILE": "${{ steps.run-agent.outputs.output-file }}",
            "ACTION_PATH": "${{ github.action_path }}"
          },
          "run": "echo \"\ud83d\udd0d Scanning AI response for leaked secrets...\"\nOUTPUT_FILE=\"$OUTPUT_FILE\"\n\n# Defensive check: ensure output file exists\nif [ -z \"$OUTPUT_FILE\" ] || [ ! -f \"$OUTPUT_FILE\" ]; then\n  echo \"\u26a0\ufe0f No output file to scan (agent may have failed during validation)\"\n  echo \"leaked=false\" >> $GITHUB_OUTPUT\n  exit 0\nfi\n\n$ACTION_PATH/security/sanitize-output.sh \"$OUTPUT_FILE\"\n\n# Extract clean output (remove verbose cagent logging, timestamps, agent markers)\necho \"\ud83e\uddf9 Extracting clean agent output...\"\n\n# Primary method: Extract from cagent-output code block (most reliable)\nif grep -q '^```cagent-output' \"$OUTPUT_FILE\"; then\n  # Extract everything between ```cagent-output and the closing ```\n  # Using awk to handle multi-line content properly\n  awk '/^```cagent-output$/,/^```$/ {\n    if (!/^```cagent-output$/ && !/^```$/) print\n  }' \"$OUTPUT_FILE\" > \"${OUTPUT_FILE}.clean\"\n\n  echo \"\u2705 Extracted clean output from cagent-output code block\"\n\n# Fallback: Extract after agent marker\nelif grep -q \"^--- Agent: root ---$\" \"$OUTPUT_FILE\"; then\n  AGENT_LINE=$(grep -n \"^--- Agent: root ---$\" \"$OUTPUT_FILE\" | tail -1 | cut -d: -f1)\n\n  # Validate AGENT_LINE is not empty before using it in arithmetic expansion\n  if [ -n \"$AGENT_LINE\" ]; then\n    tail -n +$((AGENT_LINE + 1)) \"$OUTPUT_FILE\" | \\\n      grep -v \"^time=\" | \\\n      grep -v \"^level=\" | \\\n      grep -v \"For any feedback\" | \\\n      sed '/^$/N;/^\\n$/d' > \"${OUTPUT_FILE}.clean\"\n\n    echo \"\u26a0\ufe0f  No cagent-output block found, extracted after agent marker\"\n  else\n    echo \"\u26a0\ufe0f  Failed to extract line number from agent marker\"\n    cp \"$OUTPUT_FILE\" \"${OUTPUT_FILE}.clean\"\n  fi\n\n# Fallback: Just clean metadata\nelse\n  grep -v \"^time=\" \"$OUTPUT_FILE\" | \\\n    grep -v \"^level=\" | \\\n    grep -v \"For any feedback\" > \"${OUTPUT_FILE}.clean\"\n\n  echo \"\u26a0\ufe0f  No extraction markers found - cleaned metadata only\"\nfi\n\n# Use the cleaned output\nmv \"${OUTPUT_FILE}.clean\" \"$OUTPUT_FILE\"\n"
        },
        {
          "name": "Update job summary with cleaned output",
          "if": "always()",
          "shell": "bash",
          "env": {
            "OUTPUT_FILE": "${{ steps.run-agent.outputs.output-file }}"
          },
          "run": "OUTPUT_FILE=\"$OUTPUT_FILE\"\n\n# Check if output file exists (may not exist if agent failed during validation)\nif [ -z \"$OUTPUT_FILE\" ] || [ ! -f \"$OUTPUT_FILE\" ]; then\n  echo \"\u26a0\ufe0f Output file not available, skipping summary update\"\n  exit 0\nfi\n\n# Append cleaned output to job summary\n{\n  echo \"\"\n  echo \"<hr />\"\n  echo \"\"\n  echo \"<h2>Agent Output</h2>\"\n  echo \"\"\n  cat \"$OUTPUT_FILE\"\n  echo \"\"\n} >> $GITHUB_STEP_SUMMARY\n"
        },
        {
          "name": "Handle security incident",
          "if": "steps.sanitize-output.outputs.leaked == 'true'",
          "shell": "bash",
          "env": {
            "GH_TOKEN": "${{ inputs.github-token || github.token }}",
            "REPOSITORY": "${{ github.repository }}",
            "RUN_ID": "${{ github.run_id }}"
          },
          "run": "cat <<'ERROR_MSG' >&2\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\ud83d\udea8 SECURITY INCIDENT: SECRET LEAK DETECTED\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\nA secret was detected in the AI agent response\nCheck the workflow logs for the leaked secret\n\nIMMEDIATE ACTIONS REQUIRED:\n  1. Review workflow logs for the leaked secret\n  2. Investigate the prompt/input that triggered this\n  3. Review who triggered this workflow\n  4. ROTATE ALL SECRETS IMMEDIATELY\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\nERROR_MSG\n\n# Create security incident issue\nBODY=\"**CRITICAL SECURITY INCIDENT**\n\nA secret was detected in the AI agent response for workflow run $RUN_ID\n\n## Actions Taken\n\u2713 Workflow failed with error\n\u2713 Security incident issue created\n\n## Required Actions\n1. Review workflow logs: https://github.com/$REPOSITORY/actions\n2. **ROTATE COMPROMISED SECRETS IMMEDIATELY**\n  - ANTHROPIC_API_KEY\n  - GITHUB_TOKEN\n  - OPENAI_API_KEY\n  - GOOGLE_API_KEY\n  - Any other exposed credentials\n3. Investigate the workflow trigger and input prompt\n4. Review workflow run history for suspicious patterns\n\n## Timeline\n- Incident detected: $(date -u +%Y-%m-%dT%H:%M:%SZ)\n- Workflow run: https://github.com/$REPOSITORY/actions/runs/$RUN_ID\n\n## Next Steps\n- [ ] Secrets rotated\n- [ ] Logs reviewed\n- [ ] Incident investigated\n- [ ] Incident report filed\n- [ ] Post-mortem completed\"\n\ngh issue create \\\n  --repo \"$REPOSITORY\" \\\n  --title \"\ud83d\udea8 Security Alert: Secret Leak Detected in Agent Execution\" \\\n  --label \"security\" \\\n  --body \"$BODY\"\n\necho \"\ud83d\udea8 Security incident issue created\"\nexit 1\n"
        }
      ]
    }
  },
  "annotations": {
    "categories": [],
    "confidence": null,
    "evidence": []
  },
  "cache": {
    "source_hash": "709ad72e2f281ad08f88bab1f96d695b3479f2fed3a8c660d9d868c58c1d5f53",
    "taxonomy_version": "0.0.1",
    "prompt_version": "v1",
    "generated_at": "2025-12-14T22:40:51.473782Z"
  }
}
