{
  "action_id": "marketplace/docker/ghaction-dump-context",
  "version_id": "1a53d7f818f6",
  "source": {
    "type": "marketplace",
    "action_yml_path": "blueprints/marketplace/docker/ghaction-dump-context/action.yml",
    "origin": "github.com/docker/ghaction-dump-context",
    "publisher": "docker",
    "verified": true
  },
  "definition": {
    "name": "Dump context",
    "description": "GitHub Action composite to dump context",
    "author": "crazy-max",
    "inputs": [],
    "outputs": [],
    "runs": {
      "using": "composite",
      "steps": [
        {
          "uses": "actions/github-script@v7",
          "with": {
            "script": "const fs = require('fs');\n\nawait core.group(`Env vars`, async () => {\n  const envs = Object.keys(process.env).sort().reduce(\n    (obj, key) => {\n      obj[key] = process.env[key];\n      return obj;\n    }, {}\n  );\n  core.info(JSON.stringify(Object.fromEntries(Object.entries(envs).filter(([key]) => !key.startsWith('GHACTION_DCTX_') && !key.startsWith('INPUT_'))), null, 2));\n});\n\nawait core.group(`GitHub context`, async () => {\n  core.info(JSON.stringify(JSON.parse(`${process.env.GHACTION_DCTX_GITHUB_CONTEXT}`), null, 2));\n});\nawait core.group(`Job context`, async () => {\n  core.info(JSON.stringify(JSON.parse(`${process.env.GHACTION_DCTX_JOB_CONTEXT}`), null, 2));\n});\nawait core.group(`Steps context`, async () => {\n  core.info(JSON.stringify(JSON.parse(`${process.env.GHACTION_DCTX_STEPS_CONTEXT}`), null, 2));\n});\nawait core.group(`Runner context`, async () => {\n  core.info(JSON.stringify(JSON.parse(`${process.env.GHACTION_DCTX_RUNNER_CONTEXT}`), null, 2));\n});\nawait core.group(`Strategy context`, async () => {\n  core.info(JSON.stringify(JSON.parse(`${process.env.GHACTION_DCTX_STRATEGY_CONTEXT}`), null, 2));\n});\nawait core.group(`Matrix context`, async () => {\n  core.info(JSON.stringify(JSON.parse(`${process.env.GHACTION_DCTX_MATRIX_CONTEXT}`), null, 2));\n});\n\nawait core.group(`Docker info`, async () => {\n  await exec.exec('docker', ['info'], {ignoreReturnCode: true}).catch(error => {\n    core.info(error);\n  });\n});\nawait core.group(`Docker version`, async () => {\n  await exec.exec('docker', ['version'], {ignoreReturnCode: true}).catch(error => {\n    core.info(error);\n  });\n});\nawait core.group(`Docker images`, async () => {\n  await exec.exec('docker', ['image', 'ls'], {ignoreReturnCode: true}).catch(error => {\n    core.info(error);\n  });\n});\n\nif (`${process.env.RUNNER_OS}` == 'Linux') {\n  await core.group(`Check/install deps`, async () => {\n    const required_cmds = (`${process.env.RUNNER_ARCH}` == 'X64') ? [\"lscgroup\", \"cpuid\"] : [\"lscgroup\"];\n    try {\n      await exec.exec('which', required_cmds);\n    } catch (error) {\n      core.info(\"Installing deps...\");\n      const sudo = await exec.getExecOutput('which sudo', [], {silent: true, ignoreReturnCode: true})\n      if (sudo.stdout != \"\") {\n        const aptget = await exec.getExecOutput('which apt-get', [], {silent: true, ignoreReturnCode: true})\n        if (aptget.stdout != \"\") {\n          await exec.exec('sudo', ['apt-get', 'update'], {ignoreReturnCode: true});\n          const required_deps = (`${process.env.RUNNER_ARCH}` == 'X64') ? [\"cgroup-tools\", \"cpuid\"] : [\"cgroup-tools\"];\n          await exec.exec('sudo', ['apt-get', 'install', '-y'].concat(required_deps), {ignoreReturnCode: true});\n        } else {\n          core.info('apt-get not found; not installing deps')\n        }\n      } else {\n        core.info('sudo not found; not installing deps')\n      }\n    }\n  });\n  await core.group(`Print hosts`, async () => {\n    await exec.exec('cat /etc/hosts');\n  });\n  await core.group(`Print resolv.conf`, async () => {\n    await exec.exec('cat /etc/resolv.conf');\n  });\n  await core.group(`Print cpuinfo`, async () => {\n    await exec.exec('cat /proc/cpuinfo');\n  });\n  await core.group(`Print cpuid`, async () => {\n    const cpuid = await exec.getExecOutput('which cpuid', [], {silent: true, ignoreReturnCode: true})\n    if (cpuid.stdout != \"\") {\n      await exec.exec('cpuid');\n    } else {\n      core.info('cpuid not found')\n    }\n  });\n  await core.group(`File system`, async () => {\n    await exec.exec('df -ah');\n  });\n  await core.group(`Mounts`, async () => {\n    await exec.exec('mount');\n  });\n  await core.group(`Systemd logs`, async () => {\n    const sudo = await exec.getExecOutput('which sudo', [], {silent: true, ignoreReturnCode: true})\n    if (sudo.stdout != \"\") {\n      await exec.exec('sudo journalctl --no-pager --system --user --all');\n    } else {\n      await exec.exec('journalctl --no-pager --system --user --all');\n    }\n  });\n  await core.group(`Docker daemon conf`, async () => {\n    if ((fs.statSync('/etc/docker', {throwIfNoEntry: false}) != undefined) &&\n        (fs.statSync('/etc/docker/daemon.json', {throwIfNoEntry: false}) != undefined)) {\n      core.info(JSON.stringify(JSON.parse(fs.readFileSync('/etc/docker/daemon.json', {encoding: 'utf-8'}).trim()), null, 2));\n    } else {\n      core.info('/etc/docker/daemon.json not present')\n    }\n  });\n  await core.group(`Cgroups`, async () => {\n    const lscgroup = await exec.getExecOutput('which lscgroup', [], {silent: true, ignoreReturnCode: true})\n    if (lscgroup.stdout != \"\") {\n      await exec.exec('lscgroup');\n    } else {\n      core.info('lscgroup not found')\n    }\n  });\n  await core.group(`containerd version`, async () => {\n    const containerd = await exec.getExecOutput('which containerd', [], {silent: true, ignoreReturnCode: true})\n    if (containerd.stdout != \"\") {\n      await exec.exec('containerd --version');\n    } else {\n      core.info('containerd not found')\n    }\n  });\n}\n"
          },
          "env": {
            "GHACTION_DCTX_GITHUB_CONTEXT": "${{ toJson(github) }}",
            "GHACTION_DCTX_JOB_CONTEXT": "${{ toJson(job) }}",
            "GHACTION_DCTX_STEPS_CONTEXT": "${{ toJson(steps) }}",
            "GHACTION_DCTX_RUNNER_CONTEXT": "${{ toJson(runner) }}",
            "GHACTION_DCTX_STRATEGY_CONTEXT": "${{ toJson(strategy) }}",
            "GHACTION_DCTX_MATRIX_CONTEXT": "${{ toJson(matrix) }}"
          }
        }
      ]
    }
  },
  "annotations": {
    "categories": [],
    "confidence": null,
    "evidence": []
  },
  "cache": {
    "source_hash": "1a53d7f818f64adb9a20d27d6a9610bc3fef54a0d32619874fffc3767f2f6454",
    "taxonomy_version": "0.0.1",
    "prompt_version": "v1",
    "generated_at": "2025-12-14T22:40:51.486336Z"
  }
}
