<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>terraform-apply - Actions Catalog</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <nav class="navbar">
        <div class="container">
            <a href="index.html" class="navbar-brand">üöÄ Actions Catalog</a>
        </div>
    </nav>

    <main class="container">
        <a href="index.html" class="back-link">‚Üê Back to Catalog</a>

        <div class="detail-header">
            <h1>terraform-apply</h1>
            
        </div>

        <div class="detail-meta">
            <p><strong>Action ID:</strong> <code>marketplace/dflook/terraform-apply</code></p>
            <p><strong>Author:</strong> Daniel Flook</p>
            <p><strong>Publisher:</strong> dflook</p>
            <p><strong>Repository:</strong> <a href="https://github.com/dflook/terraform-apply" target="_blank">github.com/dflook/terraform-apply</a></p>
        </div>

        <div class="section">
            <h2>Description</h2>
            <p>Apply a Terraform plan</p>
        </div>

        <div class="section"><h3>Categories</h3><p><span class="badge badge-category">Infrastructure</span> <span class="badge badge-category">Deployment</span> <span class="badge badge-category">Dependency management</span></p></div>
        <div class="section">
            <h3>Categorization</h3>
            <p><strong>Primary:</strong> Infrastructure</p>
            <p><strong>Confidence:</strong> high</p>
            <p><strong>Reasoning:</strong> The action applies a Terraform plan, which is primarily related to infrastructure management and deployment of resources. It also involves dependency management as it handles the state and outputs of Terraform configurations.</p>
            <p><strong>Tags:</strong> <span class="tag">Terraform</span> <span class="tag">Infrastructure</span> <span class="tag">Deployment</span> <span class="tag">Automation</span> <span class="tag">GitHub Actions</span></p>
        </div>
        <div class="section"><h3>Inputs</h3><table class="inputs-table"><thead><tr><th>Name</th><th>Required</th><th>Description</th></tr></thead><tbody><tr>
                <td><code>path</code></td>
                <td>No</td>
                <td>Path to the Terraform root module to apply</td>
            </tr><tr>
                <td><code>workspace</code></td>
                <td>No</td>
                <td>Terraform workspace to run the apply in</td>
            </tr><tr>
                <td><code>label</code></td>
                <td>No</td>
                <td>A friendly name for the environment the Terraform configuration is for.
This will be used in the PR comment for easy identification.

It must be the same as the `label` used in the corresponding [`dflook/terraform-plan`](https://github.com/dflook/terraform-github-actions/tree/main/terraform-plan) action.
</td>
            </tr><tr>
                <td><code>variables</code></td>
                <td>No</td>
                <td>Variables to set for the terraform plan. This should be valid Terraform syntax - like a [variable definition file](https://developer.hashicorp.com/terraform/language/values/variables#variable-definitions-tfvars-files).

Variables set here override any given in `var_file`s.
</td>
            </tr><tr>
                <td><code>var_file</code></td>
                <td>No</td>
                <td>List of tfvars files to use, one per line.
Paths should be relative to the GitHub Actions workspace
</td>
            </tr><tr>
                <td><code>backend_config</code></td>
                <td>No</td>
                <td>List of Terraform backend config values, one per line.</td>
            </tr><tr>
                <td><code>backend_config_file</code></td>
                <td>No</td>
                <td>List of Terraform backend config files to use, one per line.
Paths should be relative to the GitHub Actions workspace
</td>
            </tr><tr>
                <td><code>replace</code></td>
                <td>No</td>
                <td>List of resources to replace, one per line.</td>
            </tr><tr>
                <td><code>target</code></td>
                <td>No</td>
                <td>List of resources to apply, one per line.
The apply operation will be limited to these resources and their dependencies.
</td>
            </tr><tr>
                <td><code>destroy</code></td>
                <td>No</td>
                <td>Set to `true` to destroy all resources.

This generates and applies a plan in [destroy mode](https://developer.hashicorp.com/terraform/cli/commands/plan#planning-modes).
</td>
            </tr><tr>
                <td><code>refresh</code></td>
                <td>No</td>
                <td>Set to `false` to skip synchronisation of the Terraform state with actual resources.

This will make the plan faster but may be out of date with the actual resources, which can lead to incorrect plans.
</td>
            </tr><tr>
                <td><code>plan_path</code></td>
                <td>No</td>
                <td>Path to a plan file to apply. This would have been generated by a previous [`dflook/terraform-plan`](https://github.com/dflook/terraform-github-actions/tree/main/terraform-plan) action.

The default behaviour when this is not set is to generate a plan from the current configuration and compare it to the plan attached to the PR comment.
If it is logically the same, the plan will be applied.

When this is set to a plan file, the plan will not be generated again. If it is the exact same plan as the one attached to the PR comment, it will be applied.
This will be faster than generating a new plan.

There are downsides to applying a stored plan:

- The plan may contain sensitive information so must be stored securely, possibly outside of GitHub.
- It does not account for any changes that have occurred since it was generated, and may no longer be correct.
- Plans must be generated and applied in strict order. Multiple open PRs will cause conflicts if they are applied out of order.
- Plans are not portable between platforms.
- Terraform and provider versions must match between the plan generation and apply.

When `auto_approve` is set to `true`, the plan will be applied without checking if it is the same as the one attached to the PR comment.
</td>
            </tr><tr>
                <td><code>auto_approve</code></td>
                <td>No</td>
                <td>When set to `true`, plans are always applied.

The default is `false`, which requires plans to have been added to a pull request comment.
</td>
            </tr><tr>
                <td><code>parallelism</code></td>
                <td>No</td>
                <td>Limit the number of concurrent operations</td>
            </tr></tbody></table></div>
        <div class="section"><h3>Outputs</h3><table class="outputs-table"><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr>
                <td><code>json_plan_path</code></td>
                <td>This is the path to the generated plan in [JSON Output Format](https://www.terraform.io/docs/internals/json-format.html).
The path is relative to the Actions workspace.

Terraform plans often contain sensitive information, so this output should be treated with care.

This won&#39;t be set if the backend type is `remote` - Terraform does not support saving remote plans.
</td>
            </tr><tr>
                <td><code>text_plan_path</code></td>
                <td>This is the path to the generated plan in a human-readable format.
The path is relative to the Actions workspace.
This won&#39;t be set if `auto_approve` is true while using a `remote` backend.
</td>
            </tr><tr>
                <td><code>failure-reason</code></td>
                <td>When the job outcome is `failure`, this output may be set. The value may be one of:

- `apply-failed` - The Terraform apply operation failed.
- `plan-changed` - The approved plan is no longer accurate, so the apply will not be attempted.
- `state-locked` - The Terraform state lock could not be obtained because it was already locked.

If the job fails for any other reason this will not be set.
This can be used with the Actions expression syntax to conditionally run steps.
</td>
            </tr><tr>
                <td><code>lock-info</code></td>
                <td>When the job outcome is `failure` and the failure-reason is `state-locked`, this output will be set.

It is a json object containing any available state lock information and typically has the form:

```json
{
  &quot;ID&quot;: &quot;838fbfde-c5cd-297f-84a4-d7578b4a4880&quot;,
  &quot;Path&quot;: &quot;terraform-github-actions/test-unlock-state&quot;,
  &quot;Operation&quot;: &quot;OperationTypeApply&quot;,
  &quot;Who&quot;: &quot;root@e9d43b0c6478&quot;,
  &quot;Version&quot;: &quot;1.3.7&quot;,
  &quot;Created&quot;: &quot;2023-01-28 00:16:41.560904373 +0000 UTC&quot;,
  &quot;Info&quot;: &quot;&quot;
}
```
</td>
            </tr><tr>
                <td><code>run_id</code></td>
                <td>If the root module uses the `remote` or `cloud` backend in remote execution mode, this output will be set to the remote run id.</td>
            </tr><tr>
                <td><code>json_output_path</code></td>
                <td>This is the path to all the root module outputs in a JSON file.
The path is relative to the Actions workspace.

For example, with the Terraform config:

```hcl
output &quot;service_hostname&quot; {
  value = &quot;example.com&quot;
}
```

The file pointed to by this output will contain:

```json
{
  &quot;service_hostname&quot;: &quot;example.com&quot;
}
```

Terraform list, set and tuple types are cast to a JSON array, map and object types are cast to a JSON object.
</td>
            </tr></tbody></table></div>
    </main>

    <footer>
        <p>Generated on 2025-12-14 23:58 UTC</p>
    </footer>
</body>
</html>